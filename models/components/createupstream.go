// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/Kong/sdk-konnect-go/internal/utils"
)

// CreateUpstreamAlgorithm - Which load balancing algorithm to use.
type CreateUpstreamAlgorithm string

const (
	CreateUpstreamAlgorithmConsistentHashing CreateUpstreamAlgorithm = "consistent-hashing"
	CreateUpstreamAlgorithmLeastConnections  CreateUpstreamAlgorithm = "least-connections"
	CreateUpstreamAlgorithmRoundRobin        CreateUpstreamAlgorithm = "round-robin"
)

func (e CreateUpstreamAlgorithm) ToPointer() *CreateUpstreamAlgorithm {
	return &e
}
func (e *CreateUpstreamAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "consistent-hashing":
		fallthrough
	case "least-connections":
		fallthrough
	case "round-robin":
		*e = CreateUpstreamAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateUpstreamAlgorithm: %v", v)
	}
}

// CreateUpstreamHashFallback - What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`.
type CreateUpstreamHashFallback string

const (
	CreateUpstreamHashFallbackNone       CreateUpstreamHashFallback = "none"
	CreateUpstreamHashFallbackConsumer   CreateUpstreamHashFallback = "consumer"
	CreateUpstreamHashFallbackIP         CreateUpstreamHashFallback = "ip"
	CreateUpstreamHashFallbackHeader     CreateUpstreamHashFallback = "header"
	CreateUpstreamHashFallbackCookie     CreateUpstreamHashFallback = "cookie"
	CreateUpstreamHashFallbackPath       CreateUpstreamHashFallback = "path"
	CreateUpstreamHashFallbackQueryArg   CreateUpstreamHashFallback = "query_arg"
	CreateUpstreamHashFallbackURICapture CreateUpstreamHashFallback = "uri_capture"
)

func (e CreateUpstreamHashFallback) ToPointer() *CreateUpstreamHashFallback {
	return &e
}
func (e *CreateUpstreamHashFallback) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "consumer":
		fallthrough
	case "ip":
		fallthrough
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "path":
		fallthrough
	case "query_arg":
		fallthrough
	case "uri_capture":
		*e = CreateUpstreamHashFallback(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateUpstreamHashFallback: %v", v)
	}
}

// CreateUpstreamHashOn - What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing.
type CreateUpstreamHashOn string

const (
	CreateUpstreamHashOnNone       CreateUpstreamHashOn = "none"
	CreateUpstreamHashOnConsumer   CreateUpstreamHashOn = "consumer"
	CreateUpstreamHashOnIP         CreateUpstreamHashOn = "ip"
	CreateUpstreamHashOnHeader     CreateUpstreamHashOn = "header"
	CreateUpstreamHashOnCookie     CreateUpstreamHashOn = "cookie"
	CreateUpstreamHashOnPath       CreateUpstreamHashOn = "path"
	CreateUpstreamHashOnQueryArg   CreateUpstreamHashOn = "query_arg"
	CreateUpstreamHashOnURICapture CreateUpstreamHashOn = "uri_capture"
)

func (e CreateUpstreamHashOn) ToPointer() *CreateUpstreamHashOn {
	return &e
}
func (e *CreateUpstreamHashOn) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "consumer":
		fallthrough
	case "ip":
		fallthrough
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "path":
		fallthrough
	case "query_arg":
		fallthrough
	case "uri_capture":
		*e = CreateUpstreamHashOn(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateUpstreamHashOn: %v", v)
	}
}

type CreateUpstreamHealthy struct {
	HTTPStatuses []int64  `json:"http_statuses,omitempty"`
	Interval     *float64 `default:"0" json:"interval"`
	Successes    *int64   `default:"0" json:"successes"`
}

func (c CreateUpstreamHealthy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateUpstreamHealthy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateUpstreamHealthy) GetHTTPStatuses() []int64 {
	if o == nil {
		return nil
	}
	return o.HTTPStatuses
}

func (o *CreateUpstreamHealthy) GetInterval() *float64 {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *CreateUpstreamHealthy) GetSuccesses() *int64 {
	if o == nil {
		return nil
	}
	return o.Successes
}

type CreateUpstreamType string

const (
	CreateUpstreamTypeTCP   CreateUpstreamType = "tcp"
	CreateUpstreamTypeHTTP  CreateUpstreamType = "http"
	CreateUpstreamTypeHTTPS CreateUpstreamType = "https"
	CreateUpstreamTypeGrpc  CreateUpstreamType = "grpc"
	CreateUpstreamTypeGrpcs CreateUpstreamType = "grpcs"
)

func (e CreateUpstreamType) ToPointer() *CreateUpstreamType {
	return &e
}
func (e *CreateUpstreamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "grpc":
		fallthrough
	case "grpcs":
		*e = CreateUpstreamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateUpstreamType: %v", v)
	}
}

type CreateUpstreamUnhealthy struct {
	HTTPFailures *int64   `default:"0" json:"http_failures"`
	HTTPStatuses []int64  `json:"http_statuses,omitempty"`
	Interval     *float64 `default:"0" json:"interval"`
	TCPFailures  *int64   `default:"0" json:"tcp_failures"`
	Timeouts     *int64   `default:"0" json:"timeouts"`
}

func (c CreateUpstreamUnhealthy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateUpstreamUnhealthy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateUpstreamUnhealthy) GetHTTPFailures() *int64 {
	if o == nil {
		return nil
	}
	return o.HTTPFailures
}

func (o *CreateUpstreamUnhealthy) GetHTTPStatuses() []int64 {
	if o == nil {
		return nil
	}
	return o.HTTPStatuses
}

func (o *CreateUpstreamUnhealthy) GetInterval() *float64 {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *CreateUpstreamUnhealthy) GetTCPFailures() *int64 {
	if o == nil {
		return nil
	}
	return o.TCPFailures
}

func (o *CreateUpstreamUnhealthy) GetTimeouts() *int64 {
	if o == nil {
		return nil
	}
	return o.Timeouts
}

type CreateUpstreamActive struct {
	Concurrency            *int64                   `default:"10" json:"concurrency"`
	Headers                map[string]any           `json:"headers,omitempty"`
	Healthy                *CreateUpstreamHealthy   `json:"healthy,omitempty"`
	HTTPPath               *string                  `default:"/" json:"http_path"`
	HTTPSSni               *string                  `json:"https_sni,omitempty"`
	HTTPSVerifyCertificate *bool                    `default:"true" json:"https_verify_certificate"`
	Timeout                *float64                 `default:"1" json:"timeout"`
	Type                   *CreateUpstreamType      `default:"http" json:"type"`
	Unhealthy              *CreateUpstreamUnhealthy `json:"unhealthy,omitempty"`
}

func (c CreateUpstreamActive) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateUpstreamActive) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateUpstreamActive) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *CreateUpstreamActive) GetHeaders() map[string]any {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *CreateUpstreamActive) GetHealthy() *CreateUpstreamHealthy {
	if o == nil {
		return nil
	}
	return o.Healthy
}

func (o *CreateUpstreamActive) GetHTTPPath() *string {
	if o == nil {
		return nil
	}
	return o.HTTPPath
}

func (o *CreateUpstreamActive) GetHTTPSSni() *string {
	if o == nil {
		return nil
	}
	return o.HTTPSSni
}

func (o *CreateUpstreamActive) GetHTTPSVerifyCertificate() *bool {
	if o == nil {
		return nil
	}
	return o.HTTPSVerifyCertificate
}

func (o *CreateUpstreamActive) GetTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.Timeout
}

func (o *CreateUpstreamActive) GetType() *CreateUpstreamType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateUpstreamActive) GetUnhealthy() *CreateUpstreamUnhealthy {
	if o == nil {
		return nil
	}
	return o.Unhealthy
}

type CreateUpstreamHealthchecksHealthy struct {
	HTTPStatuses []int64 `json:"http_statuses,omitempty"`
	Successes    *int64  `default:"0" json:"successes"`
}

func (c CreateUpstreamHealthchecksHealthy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateUpstreamHealthchecksHealthy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateUpstreamHealthchecksHealthy) GetHTTPStatuses() []int64 {
	if o == nil {
		return nil
	}
	return o.HTTPStatuses
}

func (o *CreateUpstreamHealthchecksHealthy) GetSuccesses() *int64 {
	if o == nil {
		return nil
	}
	return o.Successes
}

type CreateUpstreamHealthchecksType string

const (
	CreateUpstreamHealthchecksTypeTCP   CreateUpstreamHealthchecksType = "tcp"
	CreateUpstreamHealthchecksTypeHTTP  CreateUpstreamHealthchecksType = "http"
	CreateUpstreamHealthchecksTypeHTTPS CreateUpstreamHealthchecksType = "https"
	CreateUpstreamHealthchecksTypeGrpc  CreateUpstreamHealthchecksType = "grpc"
	CreateUpstreamHealthchecksTypeGrpcs CreateUpstreamHealthchecksType = "grpcs"
)

func (e CreateUpstreamHealthchecksType) ToPointer() *CreateUpstreamHealthchecksType {
	return &e
}
func (e *CreateUpstreamHealthchecksType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "grpc":
		fallthrough
	case "grpcs":
		*e = CreateUpstreamHealthchecksType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateUpstreamHealthchecksType: %v", v)
	}
}

type CreateUpstreamHealthchecksUnhealthy struct {
	HTTPFailures *int64  `default:"0" json:"http_failures"`
	HTTPStatuses []int64 `json:"http_statuses,omitempty"`
	TCPFailures  *int64  `default:"0" json:"tcp_failures"`
	Timeouts     *int64  `default:"0" json:"timeouts"`
}

func (c CreateUpstreamHealthchecksUnhealthy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateUpstreamHealthchecksUnhealthy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateUpstreamHealthchecksUnhealthy) GetHTTPFailures() *int64 {
	if o == nil {
		return nil
	}
	return o.HTTPFailures
}

func (o *CreateUpstreamHealthchecksUnhealthy) GetHTTPStatuses() []int64 {
	if o == nil {
		return nil
	}
	return o.HTTPStatuses
}

func (o *CreateUpstreamHealthchecksUnhealthy) GetTCPFailures() *int64 {
	if o == nil {
		return nil
	}
	return o.TCPFailures
}

func (o *CreateUpstreamHealthchecksUnhealthy) GetTimeouts() *int64 {
	if o == nil {
		return nil
	}
	return o.Timeouts
}

type CreateUpstreamPassive struct {
	Healthy   *CreateUpstreamHealthchecksHealthy   `json:"healthy,omitempty"`
	Type      *CreateUpstreamHealthchecksType      `default:"http" json:"type"`
	Unhealthy *CreateUpstreamHealthchecksUnhealthy `json:"unhealthy,omitempty"`
}

func (c CreateUpstreamPassive) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateUpstreamPassive) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateUpstreamPassive) GetHealthy() *CreateUpstreamHealthchecksHealthy {
	if o == nil {
		return nil
	}
	return o.Healthy
}

func (o *CreateUpstreamPassive) GetType() *CreateUpstreamHealthchecksType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateUpstreamPassive) GetUnhealthy() *CreateUpstreamHealthchecksUnhealthy {
	if o == nil {
		return nil
	}
	return o.Unhealthy
}

type CreateUpstreamHealthchecks struct {
	Active    *CreateUpstreamActive  `json:"active,omitempty"`
	Passive   *CreateUpstreamPassive `json:"passive,omitempty"`
	Threshold *float64               `default:"0" json:"threshold"`
}

func (c CreateUpstreamHealthchecks) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateUpstreamHealthchecks) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateUpstreamHealthchecks) GetActive() *CreateUpstreamActive {
	if o == nil {
		return nil
	}
	return o.Active
}

func (o *CreateUpstreamHealthchecks) GetPassive() *CreateUpstreamPassive {
	if o == nil {
		return nil
	}
	return o.Passive
}

func (o *CreateUpstreamHealthchecks) GetThreshold() *float64 {
	if o == nil {
		return nil
	}
	return o.Threshold
}

// CreateUpstream - The upstream object represents a virtual hostname and can be used to loadbalance incoming requests over multiple services (targets). So for example an upstream named `service.v1.xyz` for a Service object whose `host` is `service.v1.xyz`. Requests for this Service would be proxied to the targets defined within the upstream. An upstream also includes a [health checker][healthchecks], which is able to enable and disable targets based on their ability or inability to serve requests. The configuration for the health checker is stored in the upstream object, and applies to all of its targets.
type CreateUpstream struct {
	// Which load balancing algorithm to use.
	Algorithm *CreateUpstreamAlgorithm `default:"round-robin" json:"algorithm"`
	// What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`.
	HashFallback *CreateUpstreamHashFallback `default:"none" json:"hash_fallback"`
	// The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
	HashFallbackHeader *string `json:"hash_fallback_header,omitempty"`
	// The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
	HashFallbackQueryArg *string `json:"hash_fallback_query_arg,omitempty"`
	// The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
	HashFallbackURICapture *string `json:"hash_fallback_uri_capture,omitempty"`
	// What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing.
	HashOn *CreateUpstreamHashOn `default:"none" json:"hash_on"`
	// The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
	HashOnCookie *string `json:"hash_on_cookie,omitempty"`
	// The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
	HashOnCookiePath *string `default:"/" json:"hash_on_cookie_path"`
	// The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
	HashOnHeader *string `json:"hash_on_header,omitempty"`
	// The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
	HashOnQueryArg *string `json:"hash_on_query_arg,omitempty"`
	// The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
	HashOnURICapture *string                     `json:"hash_on_uri_capture,omitempty"`
	Healthchecks     *CreateUpstreamHealthchecks `json:"healthchecks,omitempty"`
	// The hostname to be used as `Host` header when proxying requests through Kong.
	HostHeader *string `json:"host_header,omitempty"`
	// This is a hostname, which must be equal to the `host` of a Service.
	Name string `json:"name"`
	// The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
	Slots *int64 `default:"10000" json:"slots"`
	// An optional set of strings associated with the Upstream for grouping and filtering.
	Tags []string `json:"tags,omitempty"`
	// If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
	UseSrvName *bool `default:"false" json:"use_srv_name"`
}

func (c CreateUpstream) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateUpstream) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateUpstream) GetAlgorithm() *CreateUpstreamAlgorithm {
	if o == nil {
		return nil
	}
	return o.Algorithm
}

func (o *CreateUpstream) GetHashFallback() *CreateUpstreamHashFallback {
	if o == nil {
		return nil
	}
	return o.HashFallback
}

func (o *CreateUpstream) GetHashFallbackHeader() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackHeader
}

func (o *CreateUpstream) GetHashFallbackQueryArg() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackQueryArg
}

func (o *CreateUpstream) GetHashFallbackURICapture() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackURICapture
}

func (o *CreateUpstream) GetHashOn() *CreateUpstreamHashOn {
	if o == nil {
		return nil
	}
	return o.HashOn
}

func (o *CreateUpstream) GetHashOnCookie() *string {
	if o == nil {
		return nil
	}
	return o.HashOnCookie
}

func (o *CreateUpstream) GetHashOnCookiePath() *string {
	if o == nil {
		return nil
	}
	return o.HashOnCookiePath
}

func (o *CreateUpstream) GetHashOnHeader() *string {
	if o == nil {
		return nil
	}
	return o.HashOnHeader
}

func (o *CreateUpstream) GetHashOnQueryArg() *string {
	if o == nil {
		return nil
	}
	return o.HashOnQueryArg
}

func (o *CreateUpstream) GetHashOnURICapture() *string {
	if o == nil {
		return nil
	}
	return o.HashOnURICapture
}

func (o *CreateUpstream) GetHealthchecks() *CreateUpstreamHealthchecks {
	if o == nil {
		return nil
	}
	return o.Healthchecks
}

func (o *CreateUpstream) GetHostHeader() *string {
	if o == nil {
		return nil
	}
	return o.HostHeader
}

func (o *CreateUpstream) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateUpstream) GetSlots() *int64 {
	if o == nil {
		return nil
	}
	return o.Slots
}

func (o *CreateUpstream) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *CreateUpstream) GetUseSrvName() *bool {
	if o == nil {
		return nil
	}
	return o.UseSrvName
}
